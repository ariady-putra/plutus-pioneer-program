{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE FlexibleInstances   #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE NumericUnderscores  #-}
{-# LANGUAGE OverloadedStrings   #-}

module Main where

import Control.Monad

import Plutus.V1.Ledger.Value
import Plutus.V2.Ledger.Api
import Plutus.Model     -- (Run,
                          -- TypedValidator (TypedValidator),
                          -- adaValue, defaultBabbage, mustFail, testNoErrors,
                          -- toV2, FakeCoin (FakeCoin), fakeValue)
import PlutusTx.Prelude -- (($))
import Prelude qualified -- (IO, (.), (<>), undefined)

import ExploitableSwap qualified as OnChain

import Test.Tasty -- (defaultMain, testGroup)

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: Prelude.IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ good "Normal spending" normalSpending
      , bad  "Double spending" doubleSpending
      ]
 where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"
 
type HomeworkScript = TypedValidator OnChain.DatumSwap ()

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

setupUsers :: Prelude.Int -> Run [PubKeyHash]
setupUsers = (`replicateM` (newUser . ada $ Lovelace 1000))

lockingTx :: UserSpend -> OnChain.DatumSwap -> Value -> Tx
lockingTx usp dat price = Prelude.mconcat
  [ userSpend usp
  , payToScript swapScript (HashDatum dat) price
  ]

consumingTx :: TxOutRef -> OnChain.DatumSwap -> PubKeyHash -> Value -> Tx
consumingTx oref dat beneficiary price = Prelude.mconcat
  [ spendScript swapScript oref () dat
  , payToKey beneficiary price
  ]

doubleConsumingTx = error ()

---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------

normalSpending :: Run ()
normalSpending = do
  -- Arrange
  users <- setupUsers 2
  let [u1, u2] = users
      price = 100
      val = adaValue price
      dat = OnChain.DatumSwap u2 price
  
  -- Action
  sp <- u1 `spend` val
  submitTx u1 $ lockingTx sp dat val
  waitNSlots 100
  
  [(oref, _)] <- utxoAt swapScript
  submitTx u2 $ consumingTx oref dat u2 val
  waitNSlots 100

  -- Assert
  [[(_, _, v1)], [(_, _, v2)]] <- forM users $
    (flattenValue Prelude.<$>) . valueAt
  when (v1 /= 900 || v2 /= 1100) $
    logError "Final balances are incorrect"

doubleSpending :: Run ()
doubleSpending = Prelude.error "undefined doubleSpending"